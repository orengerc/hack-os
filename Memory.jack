// This file is part of nand2tetris, as taught in The Hebrew University,
// and was written by Aviv Yaish, and is published under the Creative 
// Common Attribution-NonCommercial-ShareAlike 3.0 Unported License 
// https://creativecommons.org/licenses/by-nc-sa/3.0/
// It is an extension to the specifications given in  
// https://www.nand2tetris.org (Shimon Schocken and Noam Nisan, 2017)
// as allowed by the Creative Common Attribution-NonCommercial-ShareAlike 3.0 
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
    static Array RAM;
	static int freeList, heapBase, heapSize;

    /** Initializes the class. */
    function void init() {
        //system constants:
		let RAM = 0;
		let heapBase = 2048;
		let heapSize = 14334;
		
        //class constants:
		let freeList = heapBase;
		let RAM[freeList] = heapSize;      // free length => all of the heap
		let RAM[freeList + 1] = 0;         // next => null
		
		return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
		//iterate over linked list
		//find block using firstFit algorithm - the first block sufficiently large
		//edit the size of the block that this fit was carved from (next is still ok)
		
        var int prev, curr, block, flag, real_size, curr_length;
        let flag = 0;
        let curr = freeList;
        let prev = 0;
        let real_size = size + 2;

        //keep iterating list as long as not found a proper block yet, or haven't reached the end of the linked list:
        while ((flag = 0) & (~(curr = 0))) { 

            //current node has enough space, take it
            if ((RAM[curr] > real_size) | (RAM[curr] = real_size)) {
                let flag = 1;
                let block = curr;
            }

            // not found yet, move forward in linked list
            else {
                let prev = curr;
                let curr = RAM[curr + 1];
            }
        }

        // OS couldn't find a proper block, so throw bad alloc exception!
        if (flag = 0) {
            return -1;
        }

        //in case found block fits memory exactly
        if (RAM[curr] = real_size) {
            
            //set previous.next to curr.next: skip over returned block
            if (~(prev = 0)){
                let RAM[prev + 1] = RAM[curr + 1];
            }
            else {
                let freeList = RAM[curr + 1];
            }
        }
        
        // if block found is larger than needed
        else { 
            let curr_length = RAM[curr];
            let block = (curr + curr_length) - real_size + 1;
            let RAM[curr] = curr_length - real_size;
        }
        let RAM[block-1] = real_size-1; // block.size = size, without overhead

        return block;

    }




    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
		let RAM[o] = freeList;
        let freeList = o-1;
        return;
    }    

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
		return RAM[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
		let RAM[address] = value;
		return;
    }

    /** Returns the maximal element contained in the given Array/object. */
	function int max(Array o) {
		var int max, i, curr;
        let max = -32766;  //-infinity
        let i = 0;
		// do Output.printInt(RAM[o-1] - 1);
        // do Output.println();
        //iterate untill the end of array:
        while(i < (RAM[o-1]-1)){
			// do Output.printInt(o[i]);
            // do Output.println();
            let curr = o[i];
			// do Output.printInt(curr);
			// do Output.println();
            //if found larger than max, switch max
            if(curr > max){
                let max = curr;
            }
            let i = i + 1;
        }
		// do Output.printInt(max);
		// do Output.println();
        // do Output.printChar(97);
		// do Output.println();

        return max;
    }
}
